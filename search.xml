<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac docker内请求http(s)失败的问题处理]]></title>
    <url>%2F2017%2F12%2F23%2Fdocker-for-mac-localhost-issue%2F</url>
    <content type="text"><![CDATA[新建了一个docker容器，发现在容器内运行go get命令时会报错： 1234567[root@27a3532133fa bin]# go get -u -v github.com/nsf/gocodegithub.com/nsf/gocode (download)# cd /home/work/data/www/go/src/github.com/nsf/gocode; git pull --ff-onlyerror: Failed connect to github.com:8888; Operation now in progress while accessing https://github.com/nsf/gocode/info/refsfatal: HTTP request failedpackage github.com/nsf/gocode: exit status 1 访问github.com时莫名其妙的多了一个8888端口，查了相关资料发现是Mac新版的docker加了个http_proxy代理：12[root@27a3532133fa bin]# echo $http_proxydocker.for.mac.localhost:8888 找了很长时间也没发现怎么去掉这个http_proxy，最后发现可以将http_proxy这个环境变量定义为空，就可以把原来那个值覆盖掉，于是在~/.bash_profile加上1export http_proxy=&quot;&quot; 再source ~/.bash_profile就可以了。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM系统redis迁移到codis实践]]></title>
    <url>%2F2017%2F04%2F26%2Fim-redis-to-codis%2F</url>
    <content type="text"><![CDATA[公司决定使用自己搭建的codis集群代替阿里云的redis，二者性能差别不大，但是自运维的codis成本更低，同时也借这次迁移来规范key的命名，统一命名成”系统(必须):子系统(必须):存储类型(可选，cache|storage):数据(必须):版本(可选):其它(可选)”的形式，方便维护。我负责IM即时通信系统的redis迁移。IM使用redis的地方很多，并且数据量很大，例如消息拉链、联系人、最近一条消息、未读消息数、黑名单、频率及敏感词限制、Token等，而消息拉链、最近一条消息和未读消息数是进行持久存储的，因此这些数据需要进行迁移。 方案为了不影响用户的使用，代码上线定在凌晨一点。数据迁移到codis的同时还要修改key，因此不能直接使用redis-port等工具将旧的redis里面的数据同步到新的codis集群，最终决定写脚本进行数据迁移。先使用keys命令模糊匹配出旧redis里的所有key，取出数据然后设置新的key批量保存到codis集群中。消息拉链的数据量很大，可以先进行一次全量的数据迁移，代码上线之前再进行一次增量数据迁移。最近一条消息和未读消息数数据时效性比较大，也在代码上线前进行同步。具体步骤如下： 将代码中记录redis key的常量文件备份一份，将原来的key修改成规范形式，并添加codis的配置文件及连接方法，写脚本通过备份的redis key文件从旧数据库读数据，然后批量写入codis集群； 在beta机器上跑脚本全量迁移消息拉链数据； 上线前IM系统停止服务，避免在上线过程中有数据写入； 从MySQL数据库取出全量迁移消息拉链之后新增的数据，添加到codis，并迁移最近一条消息和未读消息数的数据； 通过查看日志、自测等方法验证数据迁移是否成功； 代码上线； QA进行回归测试 遇到的问题及解决方法 数据迁移脚本运行时间很长(全量迁移消息拉链的脚本运行了5个小时左右)，如果直接运行脚本，断网或者终端与服务器连接断开会导致脚本停止运行解决方法：使用nohup在后台运行脚本，如下所示，并且在退出服务器时要通过exit命令退出，不能直接关掉，否则进程也会中止。 1nohup php cli.php redis_migrate migrateTotal &amp;&gt;&gt; /apps2/tmp/im/redis_migrate_migrateTotal.log 2&gt;&amp;1 &amp; 日志文件太大（最大的一个有1.8G），beta机器的一个磁盘打满了，导致进程结束解决方法：通过df命令查看磁盘空间使用情况，选择剩余空间比较大的磁盘打日志，这里选择/dev/xvdc1，即/apps2文件夹下面。 一次mset太多键值对数据，报Segmentation fault，如图：解决方法：先对数据进行分组，如5000个键值对为一组，然后循环进行mset，代码见第三部分。 从MySQL数据库查消息拉链的增量数据，报timeout exception，如图：根据日志可以看出这是一个慢查询，sql语句如下，查看表结构发现update_time字段没有建索引，而且数据量很大（查了下一对一聊天记录表有36133336条数据），所以查询慢，而另外一个字段create_time建了联合索引，根据最左前缀法则，使用create_time代替update_time将用到索引，问题得到解决。 12345678-- 慢查询sqlSELECT * FROM im_message_info_single WHERE update_time &gt; "2017-04-25 23:07:51";-- create_time和sender_r字段建立的联合索引KEY `idx_createtime_send_r` (`create_time`,`sender_r`)-- 优化之后的sqlSELECT * FROM im_message_info_single WHERE create_time &gt; "2017-04-25 23:07:51"; 使用keys命令获取所有用户一对一聊天未读消息数的key时，redis报”read error on connection”错误，如图：google了一下发现是数据量太大，读取超时的原因，通过setOption命令设置不超时解决，参见：https://nil.sh/RedisException-with-message-read-error-on-connection.html 迁完之后发现codis里找不到数据，可能是db不对，默认是db 0，通过select命令选择数据所在db之后再查看。 相关代码所有业务的消息拉链都是采用sorted set结构，所有业务的最后一条消息都是采用string结构，社区、考研、金囿、群组这几个业务的未读消息数采用hash结构，系统未读消息采用sorted set结构，一对一聊天的未读消息数采用string结构，sorted set、string和hash这三种结构的数据分别先通过keys命令获取保存所有key的数组，然后调用以下函数（略去Action函数）将数据迁移到codis。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class RedisMigrateTask extends \Phalcon\Cli\Task &#123; const CHUNK_SIZE = 5000; // 数据分组大小 public $redisInstance = null; // redis实例 public $codisInstance = null; // codis实例 /** * 批量迁移sorted set数据 * @param $oldKeys array 存储旧key的数组 * @param $oldPrefix string 旧key前缀 * @param $newPrefix string 新key前缀 */ public function migrateSortedSetData($oldKeys, $oldPrefix, $newPrefix) &#123; if ($oldKeys === false) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] failed!" . PHP_EOL; &#125; elseif (empty($oldKeys)) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] keys [&#123;$oldPrefix&#125;*] are empty!" . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] successfully!" . PHP_EOL; foreach ($oldKeys as $oldKey) &#123; $newKey = $this-&gt;getNewKey($oldKey, $oldPrefix, $newPrefix); $sortedSetData = $this-&gt;redisInstance-&gt;zRange($oldKey, 0, -1, true); $items = []; $logArr = []; foreach ($sortedSetData as $val =&gt; $score) &#123; $items[] = $score; $items[] = $val; $logArr[] = $score . ':' . $val; &#125; array_unshift($items, $newKey); $num = call_user_func_array([$this-&gt;codisInstance, 'zAdd'], $items); // 添加成功个数 if ($num === false) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old key [&#123;$oldKey&#125;] failed to migrate to codis! old score=&gt;value: " . join(',', $logArr) . PHP_EOL; &#125; elseif ($num == 0) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old key [&#123;$oldKey&#125;] has existed and is the same! old score=&gt;value: " . join(',', $logArr) . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old key [&#123;$oldKey&#125;] with &#123;$num&#125; values was migrated to codis successfully! old score=&gt;value: " . join(',', $logArr) . PHP_EOL; &#125; &#125; &#125; &#125; /** * 分组批量迁移string数据。数据太多全量用mset会报Segmentation fault, 分组mget, mset * @param $oldKeys * @param $oldPrefix * @param $newPrefix */ public function migrateKvDataChunk($oldKeys, $oldPrefix, $newPrefix) &#123; if ($oldKeys === false) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] failed!" . PHP_EOL; &#125; elseif (empty($oldKeys)) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] keys [&#123;$oldPrefix&#125;*] are empty!" . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] successfully!" . PHP_EOL; $oldKeysChunk = array_chunk($oldKeys, self::CHUNK_SIZE); foreach ($oldKeysChunk as $oldkeysGroup) &#123; $valuesGroup = $this-&gt;redisInstance-&gt;mget($oldkeysGroup); $valuesGroupAssoc = []; foreach ($oldkeysGroup as $idx =&gt; $oldKey) &#123; $newKey = $this-&gt;getNewKey($oldKey, $oldPrefix, $newPrefix); $valuesGroupAssoc[$newKey] = $valuesGroup[$idx]; &#125; $ret = $this-&gt;codisInstance-&gt;mset($valuesGroupAssoc); // bool值 if ($ret) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old kvs was migrated to codis successfully! old keys: " . join(',', $oldkeysGroup) . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old kvs failed to migrate to codis! old keys: " . join(',', $oldkeysGroup) . PHP_EOL; &#125; &#125; &#125; &#125; /** * 批量迁移hash数据 * @param $oldKeys * @param $oldPrefix * @param $newPrefix */ public function migrateHashData($oldKeys, $oldPrefix, $newPrefix) &#123; if ($oldKeys === false) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] failed!" . PHP_EOL; &#125; elseif (empty($oldKeys)) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] keys [&#123;$oldPrefix&#125;*] are empty!" . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] get keys [&#123;$oldPrefix&#125;*] successfully!" . PHP_EOL; foreach ($oldKeys as $oldKey) &#123; $hashData = $this-&gt;redisInstance-&gt;hGetAll($oldKey); $newKey = $this-&gt;getNewKey($oldKey, $oldPrefix, $newPrefix); $ret = $this-&gt;codisInstance-&gt;hMset($newKey, $hashData); // bool值 $logArr = []; foreach ($hashData as $hashKey =&gt; $hashVal) &#123; $logArr[] = $hashKey . ':' . $hashVal; &#125; if ($ret) &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old hash key [&#123;$oldKey&#125;] was migrated to codis successfully! old hash data: " . join(',', $logArr) . PHP_EOL; &#125; else &#123; echo __METHOD__ . ' [' . date('Y-m-d H:i:s') . "] old hash key [&#123;$oldKey&#125;] failed to migrate to codis! old hash data: " . join(',', $logArr) . PHP_EOL; &#125; &#125; &#125; &#125; /** * 生成新的key * @param $oldKey string 旧redis的key * @param $oldPrefix string 旧key前缀 * @param $newPrefix string 新key前缀 * @return string */ public function getNewKey($oldKey, $oldPrefix, $newPrefix) &#123; $offset = strlen($oldPrefix); $suffix = substr($oldKey, $offset); $newKey = $newPrefix . $suffix; return $newKey; &#125;&#125;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Codis</tag>
        <tag>PHP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用堆排序合并k个有序数组的PHP实现]]></title>
    <url>%2F2017%2F04%2F10%2Fphp-merge-k-sorted-array%2F</url>
    <content type="text"><![CDATA[网上有很多关于这个问题的讨论，最优的解法是利用堆排序进行合并，不过大多数是用C、Python等实现的，这里用PHP来实现。 代码假设是从小到大排序，整体思路是构建一个大小为k(k为有序数组个数)的小根堆，堆里面存储的是每个数组当前的最小值，依次取出堆顶的元素存入结果集中，然后将该元素的下一个元素放到堆顶，重新进行堆排序，再取堆顶元素，不断循环，直到所有数组中的元素都存入结果集中。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php/** * @param array $arr 要合并的有序数组组成的二维数组 * @return array */function mergeKSortedArray($arr) &#123; // 过滤掉空数组 $arr = array_filter($arr, function ($v) &#123; return empty($v) !== true; &#125;); if (empty($arr)) &#123; return []; &#125; // 如果有数组被过滤，原索引将不连续，所以要重建索引 $arr = array_values($arr); // 让堆元素从下标1开始 array_unshift($arr, []); // 构建初始堆 $lastParentNode = floor((count($arr) - 1) / 2); // 最后一个非叶子节点位置 for ($i = $lastParentNode; $i &gt; 0; $i--) &#123; adjustHeap($arr, $i); &#125; // 合并数组 $mergedArr = []; while (!empty($arr[1])) &#123; // 将第一个数组的当前元素(即堆顶)存入结果集中， $mergedArr[] = current($arr[1]); // 将第一个数组的内部指针移动到下一位，如果下一位没有元素，则删除该数组，后面的数组自动依次向前移动 if (next($arr[1]) === false) &#123; array_splice($arr, 1, 1); &#125; if (empty($arr[1])) &#123; break; &#125; adjustHeap($arr, 1); &#125; return $mergedArr;&#125;/** * 构建小根堆 */function adjustHeap(&amp;$arr, $i) &#123; $len = count($arr); $arr[0] = $arr[$i]; for ($k = $i * 2; $k &lt;= $len - 1; $k *= 2) &#123; if (($k + 1 &lt;= $len - 1) &amp;&amp; (current($arr[$k]) &gt; current($arr[$k+1]))) &#123; $k++; &#125; if (current($arr[0]) &lt; current($arr[$k])) &#123; break; &#125; $arr[$i] = $arr[$k]; $i = $k; &#125; $arr[$i] = $arr[0];&#125; 测试用psysh引入上面的代码，测试如下：]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>HeapSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phalcon框架的Model连续进行两次save操作不能保存数据库非0或非空默认值问题的探讨]]></title>
    <url>%2F2017%2F01%2F25%2Fphalcom-model-double-save%2F</url>
    <content type="text"><![CDATA[使用MySQL数据库，有些字段设置为NOT NULL，默认值非0或非空字符串，如果用Phalcon的Model连续进行两次save()操作(第二次操作需要用到第一次生成的id，所以不能合并成一次，本文中是pid字段是根据id字段生成的，确保二者的一一对应关系)，并且没有指定这些字段的值，最终的结果是这些字段的值变成了0或空字符串，而不是数据库里设置的默认值。 问题复现数据表定义：12345678910111213CREATE TABLE `product` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `pid` bigint(20) DEFAULT NULL COMMENT '产品id', `type` tinyint(4) NOT NULL DEFAULT '1' COMMENT '类型id', `status` tinyint(4) DEFAULT '1' COMMENT '状态', `provider` varchar(32) NOT NULL DEFAULT 'zlc' COMMENT '供应商', `name` varchar(64) DEFAULT NULL COMMENT '名称', `price` decimal(7,2) DEFAULT NULL COMMENT '价格', `quantity` int(11) DEFAULT NULL COMMENT '数量', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='产品' 代码层面，在Product.php里预先定义好了所有的列,并且去掉Model对于not null的验证：123456789101112131415161718192021222324252627282930313233&lt;?phpclass Product extends \Phalcon\Mvc\Model&#123; public $id; public $pid; public $type; public $status; public $provider; public $name; public $price; public $quantity; public $create_time; public $update_time; /** * 在模型初始化的时候设置模型不用进行not null验证，当模型比较多时可以在BaseModel中进行设置 */ public function initialize() &#123; //去掉model对于not null的验证 Phalcon\Mvc\Model::setup(['notNullValidations' =&gt; false]); &#125; /** * 获取模型字符串错误信息 */ public function getErrorAsString() &#123; $error_str = join(';', array_map(function ($v) &#123; return $v-&gt;getMessage(); &#125;, $this-&gt;getMessages())); return $error_str; &#125;&#125; 简单的逻辑代码在ProductController.php中给出：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass ProductController extends \Phalcon\Mvc\Controller&#123; /** * 创建一个product */ public function createAction() &#123; if (!$this-&gt;request-&gt;isPost()) &#123; $response = [ 'code' =&gt; 1, 'msg' =&gt; 'Post method is needed', ]; return $this-&gt;response-&gt;setJsonContent($response); &#125; $product = new Product(); $product-&gt;name = $this-&gt;request-&gt;getPost('name'); $product-&gt;price = $this-&gt;request-&gt;getPost('price'); $product-&gt;quantity = $this-&gt;request-&gt;getPost('quantity', 'int', 0); $succ = $product-&gt;save(); if (!$succ) &#123; error_log(__METHOD__ . ' something went wrong:' . $product-&gt;getErrorAsString()); throw new \Exception('创建product失败'); &#125; // 为了不对外暴露产品id，生成一个与id唯一对应的pid暴露给外界，这里只是简单的拼接时间戳 $product-&gt;pid = $product-&gt;id . time(); $succ = $product-&gt;save(); if ($succ) &#123; $code = 0; $msg = 'Create the product successfully!'; &#125; else &#123; error_log(__METHOD__ . ' something went wrong:' . $product-&gt;getErrorAsString()); $code = 1; $msg = 'Fail to create the product'; &#125; $response = [ 'code' =&gt; $code, 'msg' =&gt; $msg, ]; return $this-&gt;response-&gt;setJsonContent($response); &#125;&#125; 通过curl请求http://phalcon.zuolicong.com/product/create 接口(我在本地把该项目的hosts设置成了phalcon.zuolicong.com)，命令如下:1curl -i -d &quot;name=computer&amp;price=6000.00&amp;quantity=2017&quot; http://phalcon.zuolicong.com/product/create 请求成功，查看数据库结果如下： 没有传type、status、provider三个字段，但是数据库里保存的却不是这三个字段的默认值，这是怎么回事？ 使用psysh进行逐步操作以分析问题使用psysh引入该项目的入口文件，直接通过Product Model进行逐步操作复现问题。先实例化一个Product，并对type、status、provider三个字段进行赋值，然后进行第一次save()操作，操作后发现type、status、provider三个字段的值都是null： 此时数据库里的结果如下: 可以看出第一次save()之后type、status、provider三个字段保存的都是默认值，那么问题应该就是出在第二次save()之后了。此时对该实例的pid字段进行赋值之后再进行第二次save()操作，果然这三个字段的值分别变成了0、NULL和空字符串。此时问题就明朗了，第一次save()之后实例未被赋值的字段默认为null，如果再进行一次save()操作（相当于update操作），由于type和provider设置了NOT NULL，更新为null值时MySQL会自动进行转换(此时MySQL的sql_mode不能设为STRICT_TRANS_TABLES，否则将不会进行转换，而是直接中止操作，参考http://keithlan.github.io/2015/07/14/mysql_error_1048/ 和 http://xstarcd.github.io/wiki/MySQL/MySQL-sql-mode.html )，整型会转成0，字符串类型则转成空字符串(和null是有区别的)，实际上timestamp类型也会转成操作的当前时间，这点从create_time字段上就可以看出来，此外，如果将NULL插入具有AUTO_INCREMENT属性的整数列，将插入序列中的下一个编号。 而status没有设定NOT NULL，直接更新为null。 解决方案知道了原因出在实例第一次save()之后没有被赋值的字段默认为null，想到了两个解决方案如下： 首先想到的方案就是在第二次进行save()更新操作之前把未赋值的且数据库设置了非0或非空默认值的字段手动赋为默认值，这种方案虽然可行，但是比较麻烦，并且在代码层面赋了默认值，数据库设置的默认值就没有意义了; 第二个方案是利用save()方法的第二个参数$whiteList，我们来看一下save()方法的参数： 123456/** * @param array $data * @param array $whiteList * @return boolean */public function save($data = null, $whiteList = null) &#123;&#125; 当设置了save()方法的$whiteList参数时，将只对$whiteList里面的字段进行操作，其它字段会忽略，即第二次save()操作改为如下形式：1$succ = $product-&gt;save(['pid' =&gt; $product-&gt;id . time()], ['pid']); 这种方案理论上是可行的，然而实际测试结果是并没有什么卵用，不知道是Phalcon的bug还是别的什么原因，有待进一步考证。 更新之关于解决方案的讨论今天特地研究了一下Phalcon的源码，发现上述解决方案2中对save($data = null, $whiteList = null)函数的理解有误，该函数的运行原理是，如果$data为非空数组，则调用assign($data, $dataColumnMap = null, $whiteList = null)函数对模型的各个属性进行赋值，如果$whiteList参数存在，则只会对$whiteList中给出的属性进行赋值，然后进行插入（调用_doLowInsert()函数）或者更新（调用_doLowUpdate()函数）操作，对于不在$whiteList参数里的属性，虽然在assign()函数里没有赋值，最终也会进行操作，并不是像之前理解的只会insert或者update参数$whiteList里的字段。通过对源码的研究（相关源码注释参考下一节），我找到了两个比较合理且行之有效的方案: 方案一. 使用dynamic update在模型里设置dynamic update，并在第二次save（实际上执行的是update操作）前设置快照数据。Product.php里的initialize()函数改动如下：12345678910class Product extends \Phalcon\Mvc\Model&#123; public function initialize() &#123; // 去掉model对于not null的验证 Phalcon\Mvc\Model::setup(['notNullValidations' =&gt; false]); // 使用dynamic update $this-&gt;useDynamicUpdate(true); &#125;&#125; ProductController.php里createAction()的核心代码如下：123456789101112131415161718192021class ProductController extends \Phalcon\Mvc\Controller&#123; /** * 创建一个product */ public function createAction() &#123; $product = new Product(); $product-&gt;name = $this-&gt;request-&gt;getPost('name'); $product-&gt;price = $this-&gt;request-&gt;getPost('price'); $product-&gt;quantity = $this-&gt;request-&gt;getPost('quantity', 'int', 0); $succ = $product-&gt;save(); // 设置快照数据，后面修改pid字段后和快照数据对比，就只有pid字段发生了改变，由于使用了dynamic update，只会更新pid字段。需要注意的是，启用dynamic update，只有查询数据库之后才会自动设置快照数据，我用的老版本创建和更新操作并不会自动设置快照数据，因此这里需要手动设置，未赋值的为null的字段也包含在快照数组中。新版本如果使用了dynamic update，创建和更新的时候也会自动设置快照数组，和这里手动设置的效果一样。 $product-&gt;setSnapshotData($product-&gt;toArray()); // 为了不对外暴露产品id，生成一个与id唯一对应的pid暴露给外界，这里只是简单的拼接时间戳 $product-&gt;pid = $product-&gt;id . time(); $succ = $product-&gt;save(); &#125;&#125; 方案二. 使用Phalcon\Db\Adapter\Pdo\Mysql类的updateAsDict()函数updateAsDict()函数可以更新指定的字段，忽略其它字段。对于第二次使用save()函数进行更新操作，实际上源码最终是使用Phalcon\Db\Adapter\Pdo\Mysql类的update()函数实现更新的，和updateAsDict()函数类似。ProductController.php里createAction()的核心代码如下：1234567891011121314151617181920212223class ProductController extends \Phalcon\Mvc\Controller&#123; /** * 创建一个product */ public function createAction() &#123; $product = new Product(); /** * 这里不用担心sql注入，Values assigned directly or via the array of attributes are escaped/sanitized according to the related attribute data type. So you can pass an insecure array without worrying about possible SQL injections.见https://docs.phalconphp.com/zh/latest/reference/models.html */ $succ = $product-&gt;save($this-&gt;request-&gt;getPost(), ['name', 'price', 'quantity']); // 获取一个Phalcon\Db\Adapter\Pdo\Mysql实例 $connection = $product-&gt;getWriteConnection(); // 要更新的字段，为了不对外暴露产品id，生成一个与id唯一对应的pid暴露给外界，这里只是简单的拼接时间戳 $updateData = ['pid' =&gt; $product-&gt;id . time()]; // 执行更新操作 $succ = $connection-&gt;updateAsDict('product', $updateData, 'id=' . $product-&gt;id); &#125;&#125; cphalcon相关源码注释cphalcon相关源码注释见https://github.com/zuolicong/cphalcon/blob/master/phalcon/mvc/model.zep (中文是本人加的注释)，主要涉及到save(),assign(),_doLowInsert()和_doLowInsert()几个函数，如果文件不方便看也可结合commit内容看https://github.com/zuolicong/cphalcon/commit/d1787d406aa0a1600c78f04a1207f520071169db。]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>Phalcon</tag>
        <tag>cphalcon</tag>
        <tag>MySQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统下通过EasyBCD引导安装Ubuntu14.04]]></title>
    <url>%2F2016%2F03%2F02%2Fwindows-ubuntu%2F</url>
    <content type="text"><![CDATA[重装了windows系统，硬盘一不小心格式化了，之前装的Ubuntu系统也没有了，这两天再次通过EasyBCD引导安装了Ubuntu14.04搞成双系统，网上有很多这方面的资料，在这里系统的总结一下，并且包含了EasyBCD和32位以及64位Ubuntu14.04的下载地址，以后再要装windows和Ubuntu的双系统用起来也方便。 前期准备工作首先要在电脑的硬盘中分出一个区用来安装Ubuntu，桌面上右键计算机-&gt;管理-&gt;磁盘管理,找一个大的盘（例如F盘）,选中,右键菜单选择压缩卷，在“输入压缩空间量”那一栏输入用来安装Ubuntu系统的大小（我用了60000MB），然后点压缩，这60000MB将成为空闲的空间，用于后面Ubuntu系统的安装。然后下载EasyBCD和Ubuntu的安装包，下面给出了下载地址： EasyBCD2.2下载地址：http://pan.baidu.com/s/1qXwBSza 32位Ubuntu14.04下载地址：http://pan.baidu.com/s/1o6UVJRG 64位Ubuntu14.04下载地址：http://pan.baidu.com/s/1mhruuq0 这里以64位Ubuntu14.04（安装包为ubuntu-14.04-desktop-amd64.iso，32位类似）为例，下载完成之后安装好EasyBCD，将ubuntu-14.04-desktop-amd64.iso放在C盘目录下，并将ubuntu-14.04-desktop-amd64.iso里面的两个文件解压出来也放在C盘目录下，这两个文件分别是initrd.lz和vmlinuz.efi，在casper文件夹里。 操作EasyBCD打开EasyBCD，点击“添加新条目”，然后选择“NeoGrub”，点击“安装”，再点击配置，如下图：这时会弹出一个menu.lst文件，将menu.lst文件里的内容替换成以下内容：12345678title Install Ubunturoot (hd0,0)kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-14.04-desktop-amd64.iso locale=zh_CN.UTF-8initrd (hd0,0)/initrd.lztitle rebootreboottitle halthalt hd0后面的数字表示C盘所处的硬盘顺序，一般C盘是第一个盘，表示为hd0，如果C盘是第二个盘，则为hd1，依此类推。如果自己的Ubuntu的安装包名称与上述文字中的不相符，或者initrd.lz和vmlinuz.efi文件没有后缀名，则要把上面相应的地方改成符合自己的安装包情况的名称。至此，C盘会多出一个NST文件夹和四个文件，这时就可以重启电脑准备安装Ubuntu14.04了。 安装Ubuntu系统重启电脑，可以看到多了一个启动项“NeoGrub引导加载器”，选择该项enter，然后选择“install ubuntu”，另外两项分别是“重启”和“关机”，是为了防止安装出错而设的，这个在之前的menu.lst配置文件中已经设定好了。接下来如果正常的话就会自动执行相关命令，屏幕会被命令行刷屏，这时只需要等它执行完，如果在这一步报错，一般来说就是之前的menu.lst配置文件不对，无法访问C盘，这时只要“reboot”然后进入windows系统重新配置就行。命令执行完之后就进入了一个临时的Ubuntu系统：但是这还没完，接下来按照以下步骤进行： 按Ctrl+Alt+T组合键进入终端，输入“sudo umount -l /isodevice”并enter; 双击桌面的“安装Ubuntu14.04 LTS”图标进行安装； 在“欢迎”界面，语言选择中文（简体）； 在“准备安装Ubuntu”界面，不用选中“安装中下载更新”和“安装这个第三方软件选项”，否则会安装比较慢，这些可以在Ubuntu系统安装好之后再进行。为保险起见，安装过程可以不用联网； 在“安装类型界面”，选择“其它选项（您可以自己创建、调整分区，或者为Ubuntu选择多个分区）”； 然后就要设置分区了我设置了交换空间、/boot、/home和/四个分区。双击显示为空闲的设备（其大小为你最初在硬盘分出的区的大小，我这里为60000MB），就会弹出“创建分区”窗口，需要你设置每个分区的大小，类型，位置，用于和挂载点，每一个分区设置完成之后，点击确定，然后再次双击“空闲”设备，设置下一个分区，直到所有的分区设置完毕，新分区的位置都是空间起始位置，每个分区的其它设置及说明如下表所示（以60G空闲空间为例，）： 大小 类型 用于 挂载点 说明 6000MB 逻辑分区 交换空间 无 缓存,一般与电脑内存差不多大 200MB 逻辑分区 Ext4日志文件系统 /boot 启动引导区 40000MB 逻辑分区 Ext4日志文件系统 /home 类似于windows下我的文档 剩下的空间 主分区 Ext4日志文件系统 / 系统盘 注意，所有分区都设置好之后下面还有一个“安装启动引导器的设备”，其位置要选择/boot所在的sda*, 例如的/boot所在的分区为/dev/sda8,则选择/dev/sda8。都设置好之后点击“现在安装”，然后设置地区默认即可，直接继续，键盘布局选择汉语，然后设置姓名、计算机名、用户名和密码，建议计算机名和用户名设置简短一点，这样以后打开Ubuntu终端每行前面不会有很长一串文字。以上都搞定之后就可以安装Ubuntu了，等待一段时间直到安装好，然后重启电脑进入windows系统，完成剩下的工作。 剩下的工作重启电脑进入windows之后，打开EasyBCD，点击添加新条目-&gt;操作系统-&gt;NeoGrub-&gt;删除，将“NeoGrub”引导项删除（此时C盘里的NeoGrub文件就没有了），否则每次打开电脑都会出现“NeoGrub引导加载器”选项。然后点击“Linux/BSD”设置ubuntu启动项，类型选择GRUB(Legacy)，名称自定义，驱动器选择当初/boot所在分区（根据大小来判定，如果当初/boot分区设置为200MB，这里显示的大小稍小于200MB的分区即为/boot分区）,我的是选择Linux-190MB。然后就可以把C盘里的Ubuntu安装包文件及initrd.lz和vmlinuz.efi文件删除，精简C盘。注意，C盘里的NST文件夹不能删！因为它是为Ubuntu系统启动提供驱动的，如果删除那么Ubuntu将不能启动，对此我有血的教训，因为不小心将NST文件夹删除，启动Ubuntu报错，后来通过数据恢复软件将NST文件恢复，Ubuntu才正常启动。下面这个图比较明了的说明了问题：上述工作都完成之后就可以重启电脑，这时就可以选择你想要进入的系统了。]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git打tag的方法和技巧]]></title>
    <url>%2F2016%2F01%2F23%2Fgit-tag%2F</url>
    <content type="text"><![CDATA[使用git作为版本控制工具，在代码上线之前需要打tag，便于团队有条不紊地上线代码。在这里总结一下打tag的方法与可能用到的技巧。 打tag并上线的常规流程一般是基于master分支打tag并推送tag到远程仓库，然后上线。要上线的代码合到master分支上之后，切换到master分支，pull最新代码，然后查看远程仓库的最新tag（假设为release_im_v0.0.9.8），在其基础上打tag release_im_v0.0.9.9。然后查看线上tag是哪一个（假设为release_im_v0.0.9.7），将新打的tag与线上tag进行diff，看代码有没有冲突，或者有没有别人合到master上但是暂时还不能上线的代码，如果没有问题，就可以把tag推送到远程仓库，然后请QA君帮忙上线。需要注意的是不能直接在线上tag的基础上加一作为新的tag，因为在你打tag期间团队其他人可能也打了tag，只是还没来得及上线而已，为避免冲突，需要基于远程仓库的最新tag打新tag。打tag并上线的流程如下： 12345678$ git checkout master$ git pull$ git tag|grep im|tail #查看远程仓库含有im的最新tag$ git tag -a release_im_v0.0.9.9 -m &apos;im咨询记录更改&apos; #一般打含有附注的标签$ git diff release_im_v0.0.9.7 release_im_v0.0.9.9 #如果改动比较多，也可以在gitlab上进行diff（当然要先push）#如果diff没有问题，就可以把tag推送到远程仓库，远程仓库如果是origin，则可省略origin$ git push [origin] release_im_v0.0.9.9 #推送具体的tag到远程仓库$ git push [origin] --tags #一次推送所有的tag到远程仓库 如果diff有冲突，或者master分支上含有不能上线的代码，或者要修改一个线上的bug比较紧急，就需要基于线上tag拉分支，把自己的修改的代码应用到该分支，然后在该分支上打tag上线。需要注意的是，基于自己的分支打tag上完线，还是要把该分支合到master上，不然自己改动的代码会被后面基于master的tag所覆盖。 基于线上tag修改代码并上线当需要解决线上bug比较紧急，则需要基于线上tag拉分支，在该分支修改代码并打tag上线。步骤如下（依然假设线上tag为release_im_v0.0.9.7，远程仓库最新tag为release_im_v0.0.9.8）：1234567$ git fetch --tags #查看远程仓库的tag$ git branch new_branch release_im_v0.0.9.7 #基于线上tag拉分支new_branch$ git checkout new_branch #切到该分支并修改代码解决bug$ git commit -am &apos;fix bug&apos; #tag默认打在最新提交的commit上$ git tag -a release_im_v0.0.9.9 -m &apos;fix bug&apos; $ git diff release_im_v0.0.9.7 release_im_v0.0.9.9$ git push --tags git cherry-pick的用法当需要把某个分支的某次commit应用到另外一个分支，git cherry-pick命令就派上用场了。假设我们现在在a分支上，该分支上有一个commit（假设其哈希码为d986206）需要应用到b分支上，那么可以这么做：1234$ git log --oneline #查看a分支commit历史找到需要应用到b分支上的commit的哈希码为d986206$ git show d986206 #确认commit内容$ git checkout b$ git cherry-pick d986206 基于线上tag打补丁并上线假如我们在自己的test分支修改了很多代码，合到master之后发现master不能上线，而且该分支同时修改了两个相关的线上的tag（例如PC站和手机m站），需要分别把相应的修改应用到相应的tag上，并上线，由于commit的次数比较多，用cherry-pick就比较麻烦，这时我们就需要打补丁了。现在假设PC站线上tag和远程仓库最新tag都是release_www_v3.2.2.6，手机m站线上tag和远程仓库最新tag都是release_m_v3.0.8.3，运用第二部分中的方法基于线上tag分别拉取PC站和m站的分支www-patch和m-patch。首先我们在自己的分支（这里是test分支）运行 git log –oneline 查看commit信息：发现544cf8c（主站获取id）、86721b7（m站获取id）、3971048（获取主站name）和f788477（获取m站name）这四次commit是需要上线的改动，于是我们将当前test分支与fb20a04（建立m类）这次commit进行diff以查看前四个commit的内容，确认无误后就可以打补丁了： 1$ git diff fb20a04 test &gt; patch 用vim打开patch文件截取部分如下：接下来切换到需要应用补丁的分支并应用该补丁：123456$ git checkout www-patch$ git apply patch #在www-patch分支应用补丁$ git diff #查看应用补丁之后的diff以确认无误$ rm patch #删除patch文件，git不需要追踪该文件，便于commit$ git commit -am &apos;apply patch&apos;$ git tag -a release_www_v3.2.2.7 -m &apos;打补丁上线&apos; 当然也可以把patch文件放在~/目录下，假设代码文件夹也在~/目录下，然后这样打补丁： 12345$ git diff fb20a04 test &gt; ~/patch$ git checkout www-patch$ patch -p1&lt;~/patch$ git commit -am &apos;apply patch&apos;$ git tag -a release_www_v3.2.2.7 接下来就是打手机m站的tag，这时我们就可以用git cherry-pick方法了，先在www-patch分支查看应用补丁的commit：然后应用到m-patch分支： 12345$ git checkout m-patch$ git cherry-pick 584f3ef$ git commit -am &apos;apply patch&apos;$ git tag -a release_m_v3.0.8.4 -m &apos;打补丁上线&apos;$ git push --tags #最后把新打的tag都推送到远程仓库以上线 基于特定的commit打tag假如我们想基于cf57ec4（建立www类）这次commit打tag，可以这样做： 1$ git tag -a www0.9.9 cf57ec4 -m &apos;建立www类&apos; 运行git show www0.9.9命令查看该tag信息，可以看到是基于cf57ec4（建立www类）这次commit打的：打tag时如果不指定commit，则默认基于当前分支的最新一次commit打。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phalcon框架中添加日志]]></title>
    <url>%2F2016%2F01%2F05%2Fphalcon-log%2F</url>
    <content type="text"><![CDATA[日志可以在程序出现bug时帮助排查问题，如果没有日志在解决bug时很可能无从下手。这两天修改了一个发邮件的功能，期间在自测代码的时候对日志接触的比较多，也意识到其重要性，在这里小结一下。由于公司使用的是Phalcon框架，因此这篇文章主要说说在Phalcon框架下添加日志。 在Phalcon框架下添加日志Phalcon框架下添加日志的方法如下： 12345678910111213//可以添加不同级别的日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;critical("message"); //critical级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;emergency("message"); //emergency级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;fatal("message"); //fatal级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;debug("message"); //debug级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;error("message"); //error级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;info("message"); //只记录相关信息，不给出错误级别，也可能没有错误\Phalcon\DI::getDefault()-&gt;getLog()-&gt;notice("message"); //notice级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;warning("message"); //warning级别日志\Phalcon\DI::getDefault()-&gt;getLog()-&gt;alert("message"); //alert级别日志//也可以直接使用log()方法，加一个表示错误级别的常量参数（可省略）\Phalcon\DI::getDefault()-&gt;getLog()-&gt;log("message"[,ERROR LEVEL]); 例如： 1234567891011121314151617181920212223//1中的发邮件功能在线上环境时可以这样添加日志$to = 'zuolicong@foxmail.com';foreach ($areaAttachs as $city =&gt; $attachs) &#123; $title = $city . "IM响应记录\r\n"; $body = "附件为" . $city . "IM响应记录\r\n"; $mailTarget = $this-&gt;getAreaMailer($city); if ($mailTarget) &#123; //收件人存在 $mailTarget = explode(',',$mailTarget); $ret = Lib\Email::send($to, $title, $body, (array) $mailTarget, $attachs); \Phalcon\DI::getDefault()-&gt;getLog()-&gt;info(date('Y-m-d H:i:s') . " send mail to:&#123;$to&#125; city:&#123;$city&#125; ret:" . json_encode($ret)); &#125; else &#123; //邮件发送失败的日志 \Phalcon\DI::getDefault()-&gt;getLog()-&gt;info(date('Y-m-d H:i:s') . " cant not found mail receiver city:&#123;$city&#125;"); &#125;&#125;//添加error级别的日志if ($ins-&gt;save()) &#123; return true;&#125; else &#123; \Phalcon\DI::getDefault()-&gt;getLog()-&gt;error(__method__ . " error with message:" . $ins-&gt;getErrorAsString()); return false;&#125; 正常情况下Phalcon日志会自动记录时间，但是在命令行运行不会记录，如果要在命令行运行或测试代码，例如执行定时脚本任务等，可以记录时间，这样便于在出错时尽快找出原因所在。此外，如果想要日志直接在终端输出，可以在函数的第一行加上下面这种用法： 1\Phalcon\DI::getDefault()-&gt;getLog()-&gt;toConsole=1; Phalcon日志详细用法可以参考：日志记录（Logging） — Phalcon 2.0.8 文档 - Phalcon PHP 在哪里添加日志比较合适一般来说容易出错的函数最好添加日志，便于排查问题，例如上述的发邮件函数。在开发的时候有些地方不知道是否容易出错，但是后续过程中如果出现了bug，就会知道哪些地方容易出错，可以加上日志。还是以发邮件功能为例，突然有一天南京那边的分公司说没有收到邮件，但是其它的分公司都收到了（后面发现有少数几家分公司也没有收到邮件，只是没有在意而已），经排查发现原来是生成邮件附件时出问题了，附件内容用iconv(“UTF-8”, “GB2312”, $contents)函数进行字符编码转换时$contents含有特殊字符转换失败，iconv()函数返回false，导致附件内容为空，邮件不发送，在修复了这个bug之后给iconv()函数添加了日志如下： 123456789101112private function createAttach($fileName, $contents) &#123; if (!$contents) &#123; return false; &#125; $contents = iconv("UTF-8", "GB18030//IGNORE", $contents); //忽略特殊字符 if($contents)&#123; return file_put_contents($fileName, $contents); &#125; else &#123; \Phalcon\DI::getDefault()-&gt;getLog()-&gt;info(date('Y-m-d H:i:s') . " 字符编码转换失败！"); return false; &#125;&#125; 需要注意的是file_put_contents()函数也容易出错从而返回false，因此这里选择给file_put_contents()函数添加日志也是可以的。此外在次数不是很多的循环中可以添加日志，这样可以知道每条是否执行成功。 查看日志日志一般在/tmp/或者/apps/log/文件夹里，假如我们要查看的日志文件为daily_mail.log，可以使用tail命令查看最近的日志： 1tail -f daily_mail.log 或者先用less命令打开日志文件，再shift+g跳到日志末尾，然后用k/j进行上/下翻动： 1less daily_mail.log 如果需要查找包含特定信息的日志内容，例如查找包含南京的最近的日志，可以这样做： 1tail -f daily_mail.log | grep 南京 如果需要查看所有包含南京的日志信息，可以这样做： 1cat daily_mail.log | grep 南京]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>Phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵活使用PHP和MySQL处理时间]]></title>
    <url>%2F2015%2F12%2F16%2Fphp-mysql-time%2F</url>
    <content type="text"><![CDATA[PHP的时间函数很多，用法也多样，而MySQL也有丰富的日期和时间类型进行相应的支持，因此在用PHP和MySQL处理时间时可以灵活一点，尽可能提高代码的可重用性和降低耦合度。 MySQL常用的时间数据类型在使用MySQL数据库存储时间变量时字段类型尽量使用MySQL已有的时间数据类型，更方便而且效率更高。MySQL常用的时间数据类型如下： 时间类型 存储空间 时间格式 datetime 8 bytes YYYY-MM-DD HH:MM:SS timestamp 4 bytes YYYY-MM-DD HH:MM:SS date 3 bytes YYYY-MM-DD time 3 bytes HH:MM:SS 一般来说，如果需要在数据库存储时间信息，最好把日期和具体时间都纪录下来，即使产品经理提的需求只是日期或者具体时间，以防后面会用到，比如说按时间排序，或者需要以时间为条件查找某些数据，因此最好使用datetime数据类型或者timestamp。代码如下： 1`create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos; 灵活使用PHP时间函数有时候产品经理提的需求可能不需要显示完整的日期或者时间信息，比如”11-26 10:00:01”的时间格式，我们在MySQL数据库中存储时间数据时是不是就不能用时间数据类型了呢，而是改用字符串类型等等？大可不必，还是可以用，后面需要显示什么样的时间格式可以由PHP时间函数来完成，譬如显示”11-26 10:00:01”的时间格式可以这样做： 1$time = date('m-d H:i:s',strtotime($datetime)); 将时间变量设为常量以提高代码的可重用性当然不只是时间变量，只要是用的多的变量都应该设置成常量，要修改只需要修改常量的值即可，而不需要修改所有用到这些变量的代码。我最近写了一个爱视恒恩免费录课活动的后台，因为该活动分为几期进行，我写的第一期，为了提高代码可重用性，将活动开始时间和结束时间等时间变量都设为常量，后面几期活动只需要修改活动开始时间和结束时间即可，其它代码都可以直接搬过来用了。 12345678910111213const START_TIME = '2015-11-28 10:00:00'; //活动开始时间const END_TIME = '2015-12-06 23:59:59'; //活动结束时间const EVERYDAY_TIME = '10:00:00'; //活动期间每天的开始时间$start_time = date('Y-m-d')." ".(self::EVERYDAY_TIME); //活动期间每天完整的开始时间$time = time();if($time&lt;strtotime(self::START_TIME))&#123; $join_status = 1; //未到活动开始日期&#125; elseif($time&gt;strtotime(self::END_TIME))&#123; $join_status = 2; //活动已经结束&#125; elseif($time&lt;strtotime($start_time))&#123; $join_status = 7; //在活动期间，但是没到当天的开始时间&#125; 获取起始日期和结束日期的日期序列因为在开发过程中需要按天来取数据库中的数据，因此需要获取从起始日期到结束日期的日期序列，我最开始的做法是直接计算总天数，然后将intval(date(‘d’))加一，这样在下个月的时候intval(date(‘d’))与这个月的intval(date(‘d’))不连续，还要进行判断，代码的耦合度很高，不利于重复利用，正确的姿势应该是这样： 12345678910111213141516public static function getDateSeq($start_date, $end_date) &#123; $te = strtotime($end_date); $ts = strtotime($start_date); if ($te &lt; $ts) &#123; //如果结束日期小于起始日期，则交换 $tmp = $ts; $ts = $te; $te = $tmp; &#125; $seq = []; for ($i = $ts; $i &lt;= $te;) &#123; $currDate = date('Y-m-d', $i); $i = strtotime("+1 day &#123;$currDate&#125;"); //i自增一天 $seq[] = $currDate; &#125; return $seq;&#125; 或者使用PHP自带的时间类：123456789101112public static function getDateRange($start_date, $end_date, $format = 'Y-m-d') &#123; $begin = new \DateTime($start_date); $end = new \DateTime($end_date); $end-&gt;modify('+1 day'); // 这个period不包含结束时间 $interval = new \DateInterval('P1D'); $date_range = new \DatePeriod($begin, $interval, $end); $range = []; foreach ($date_range as $date) &#123; $range[] = $date-&gt;format($format); &#125; return $range;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[All categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[brief 一万小时的锤炼是任何人从平凡变成超凡的必要条件。 contact email: zuolicong@foxmail.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[All tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
